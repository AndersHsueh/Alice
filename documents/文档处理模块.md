---
title: æ–‡æ¡£å¤„ç†æ¨¡å—
aliases: [æ–‡æ¡£å¤„ç†, DocumentProcessing]
tags: [åŠŸèƒ½æ¨¡å—, æ–‡æ¡£å¤„ç†, è‡ªåŠ¨åŒ–]
date: 2026-02-11
version: 0.3.0
status: è§„åˆ’ä¸­
priority: P1
---

# æ–‡æ¡£å¤„ç†æ¨¡å— ğŸ“„

> **æ¨¡å—å®šä½**: æ™ºèƒ½åŒ–çš„æ–‡æ¡£è¯»å–ã€åˆ†æå’Œå¤„ç†èƒ½åŠ›

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

### æ ¸å¿ƒä»·å€¼

æ–‡æ¡£å¤„ç†æ¨¡å—æ—¨åœ¨è§£å†³åŠå…¬åœºæ™¯ä¸­çš„**æ–‡æ¡£å¤„ç†ä½æ•ˆ**é—®é¢˜ï¼Œé€šè¿‡ AI å®ç°ï¼š

- ğŸ“– å¤šæ ¼å¼æ–‡æ¡£è‡ªåŠ¨è§£æ (Word, PDF, Excel)
- ğŸ” æ™ºèƒ½å†…å®¹æå–ä¸åˆ†æ
- ğŸ“Š æ•°æ®å¯è§†åŒ–ä¸ç»Ÿè®¡
- ğŸ”„ æ ¼å¼è½¬æ¢ä¸æ ‡å‡†åŒ–

### ç›®æ ‡ç”¨æˆ·

| ç”¨æˆ·ç±»å‹ | å…¸å‹åœºæ™¯ | æ ¸å¿ƒéœ€æ±‚ |
|---------|---------|---------|
| è¡Œæ”¿äººå‘˜ | æ–‡æ¡£æ•´ç†ã€æ ¼å¼è½¬æ¢ | æ‰¹é‡å¤„ç†æ–‡æ¡£ |
| è´¢åŠ¡äººå‘˜ | Excel æ•°æ®åˆ†æ | å¿«é€Ÿç”ŸæˆæŠ¥è¡¨ |
| åˆ†æå¸ˆ | æ•°æ®æå–ã€å¯è§†åŒ– | æ´å¯Ÿå‘ç° |
| ç®¡ç†äººå‘˜ | æŠ¥å‘Šé˜…è¯»ã€å†³ç­–æ”¯æŒ | å¿«é€Ÿç†è§£è¦ç‚¹ |

### æŠ€æœ¯ä¾èµ–

- **docx**: Word æ–‡æ¡£è§£æ
- **pdf-parse**: PDF å†…å®¹æå–
- **xlsx**: Excel è¯»å†™
- **mammoth**: é«˜è´¨é‡ Word è½¬ HTML
- **chart.js**: æ•°æ®å¯è§†åŒ–

## ğŸ¯ åŠŸèƒ½è®¾è®¡

### åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | çŠ¶æ€ | è®¡åˆ’ç‰ˆæœ¬ | è¯´æ˜ |
|------|--------|------|---------|------|
| Word æ–‡æ¡£è¯»å– | P0 | ğŸ”„ è§„åˆ’ä¸­ | v0.3.0 | æå–æ–‡æœ¬å’Œæ ¼å¼ |
| PDF æ–‡æ¡£è§£æ | P0 | ğŸ”„ è§„åˆ’ä¸­ | v0.3.0 | æ–‡æœ¬æå– + OCR |
| Excel æ•°æ®è¯»å– | P0 | ğŸ”„ è§„åˆ’ä¸­ | v0.3.0 | è¡¨æ ¼æ•°æ®è§£æ |
| å†…å®¹ç»“æ„åŒ– | P0 | ğŸ”„ è§„åˆ’ä¸­ | v0.3.0 | æå–æ ‡é¢˜ã€æ®µè½ã€è¡¨æ ¼ |
| æ ¼å¼è½¬æ¢ | P1 | ğŸ”„ è§„åˆ’ä¸­ | v0.4.0 | Markdown/HTML/PDF |
| æ•°æ®ç»Ÿè®¡åˆ†æ | P1 | ğŸ”„ è§„åˆ’ä¸­ | v0.4.0 | Excel æ•°æ®åˆ†æ |
| å›¾è¡¨ç”Ÿæˆ | P2 | ğŸ“‹ æœªå¼€å§‹ | v0.5.0 | å¯è§†åŒ–å›¾è¡¨ |
| æ‰¹é‡å¤„ç† | P2 | ğŸ“‹ æœªå¼€å§‹ | v0.5.0 | æ‰¹é‡æ–‡æ¡£æ“ä½œ |

### 1. Word æ–‡æ¡£å¤„ç†

#### åŠŸèƒ½è¯´æ˜

æ”¯æŒè¯»å– .docx æ ¼å¼æ–‡æ¡£ï¼Œæå–æ–‡æœ¬ã€æ ¼å¼ã€è¡¨æ ¼ã€å›¾ç‰‡ç­‰å†…å®¹ã€‚

#### æŠ€æœ¯æ–¹æ¡ˆ

```typescript
// Word æ–‡æ¡£ç»“æ„
interface WordDocument {
  filePath: string;
  metadata: {
    title: string;
    author: string;
    created: Date;
    modified: Date;
    pages: number;
    words: number;
  };
  content: DocumentContent;
}

interface DocumentContent {
  text: string;              // çº¯æ–‡æœ¬
  html: string;              // HTML æ ¼å¼
  markdown: string;          // Markdown æ ¼å¼
  sections: Section[];       // ç« èŠ‚
  tables: Table[];           // è¡¨æ ¼
  images: Image[];           // å›¾ç‰‡
}

interface Section {
  level: number;             // æ ‡é¢˜çº§åˆ«
  title: string;             // æ ‡é¢˜
  content: string;           // å†…å®¹
}
```

#### å®ç°ç¤ºä¾‹

```typescript
import * as docx from 'docx';
import mammoth from 'mammoth';

class WordDocumentProcessor {
  async read(filePath: string): Promise<WordDocument> {
    // 1. è¯»å–æ–‡æ¡£
    const buffer = await fs.readFile(filePath);
    
    // 2. æå–å…ƒæ•°æ®
    const metadata = await this.extractMetadata(buffer);
    
    // 3. è½¬æ¢ä¸º HTML
    const { value: html } = await mammoth.convertToHtml({ buffer });
    
    // 4. æå–çº¯æ–‡æœ¬
    const { value: text } = await mammoth.extractRawText({ buffer });
    
    // 5. è½¬æ¢ä¸º Markdown
    const markdown = await mammoth.convertToMarkdown({ buffer });
    
    // 6. æå–ç»“æ„åŒ–å†…å®¹
    const sections = this.parseSections(html);
    const tables = this.parseTables(html);
    
    return {
      filePath,
      metadata,
      content: {
        text,
        html,
        markdown: markdown.value,
        sections,
        tables,
        images: []
      }
    };
  }
  
  private parseSections(html: string): Section[] {
    // è§£æ HTML æå–ç« èŠ‚
    const sections: Section[] = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
      sections.push({
        level: parseInt(heading.tagName[1]),
        title: heading.textContent,
        content: this.getContentAfterHeading(heading)
      });
    });
    
    return sections;
  }
}
```

#### ä½¿ç”¨åœºæ™¯

```
ç”¨æˆ·: "è¯»å–è¿™ä¸ª Word æ–‡æ¡£å¹¶æ€»ç»“è¦ç‚¹"

å·¥å…·è°ƒç”¨: readWordDocument({ filePath: "report.docx" })

è¿”å›: {
  metadata: { title: "æœˆåº¦æŠ¥å‘Š", pages: 5, words: 2500 },
  content: {
    sections: [
      { level: 1, title: "æ‰§è¡Œæ‘˜è¦", content: "..." },
      { level: 1, title: "æ•°æ®åˆ†æ", content: "..." }
    ]
  }
}

AI åˆ†æå¹¶æ€»ç»“:
ğŸ“Š æœˆåº¦æŠ¥å‘Šæ‘˜è¦
1. æ‰§è¡Œæ‘˜è¦: ...
2. æ•°æ®åˆ†æ: ...
3. å…³é”®å‘ç°: ...
```

### 2. PDF æ–‡æ¡£å¤„ç†

#### åŠŸèƒ½è¯´æ˜

æå– PDF æ–‡æ¡£çš„æ–‡æœ¬å†…å®¹ï¼Œæ”¯æŒæ–‡æœ¬å‹ PDF å’Œæ‰«æå‹ PDF (OCR)ã€‚

#### æŠ€æœ¯æ–¹æ¡ˆ

```typescript
import pdfParse from 'pdf-parse';
import Tesseract from 'tesseract.js';

class PDFDocumentProcessor {
  async read(filePath: string): Promise<PDFDocument> {
    const buffer = await fs.readFile(filePath);
    
    // 1. åŸºç¡€è§£æ
    const pdfData = await pdfParse(buffer);
    
    // 2. æå–æ–‡æœ¬
    let text = pdfData.text;
    
    // 3. å¦‚æœæ˜¯æ‰«æç‰ˆ (æ–‡æœ¬å°‘)ï¼Œä½¿ç”¨ OCR
    if (text.length < 100 && pdfData.numpages > 0) {
      text = await this.performOCR(buffer);
    }
    
    return {
      filePath,
      metadata: {
        title: pdfData.info?.Title || '',
        author: pdfData.info?.Author || '',
        pages: pdfData.numpages,
        created: pdfData.info?.CreationDate
      },
      content: {
        text,
        pages: this.splitPages(text, pdfData.numpages)
      }
    };
  }
  
  private async performOCR(buffer: Buffer): Promise<string> {
    // ä½¿ç”¨ Tesseract.js è¿›è¡Œ OCR
    const result = await Tesseract.recognize(buffer, 'chi_sim+eng');
    return result.data.text;
  }
}
```

#### ä½¿ç”¨åœºæ™¯

```
ç”¨æˆ·: "è¿™ä¸ª PDF æ–‡æ¡£è®²äº†ä»€ä¹ˆ?"

å·¥å…·è°ƒç”¨: readPDFDocument({ filePath: "contract.pdf" })

è¿”å›: {
  metadata: { pages: 12 },
  content: {
    text: "åˆåŒå†…å®¹...",
    pages: ["ç¬¬1é¡µå†…å®¹...", "ç¬¬2é¡µå†…å®¹..."]
  }
}

AI å›å¤:
ğŸ“„ æ–‡æ¡£æ‘˜è¦:
è¿™æ˜¯ä¸€ä»½12é¡µçš„åˆåŒæ–‡æ¡£ï¼Œä¸»è¦å†…å®¹åŒ…æ‹¬:
1. åˆåŒåŒæ–¹: Aå…¬å¸ ä¸ Bå…¬å¸
2. åˆä½œå†…å®¹: ...
3. å…³é”®æ¡æ¬¾: ...
```

### 3. Excel æ•°æ®å¤„ç†

#### åŠŸèƒ½è¯´æ˜

è¯»å– Excel è¡¨æ ¼ï¼Œæå–æ•°æ®ï¼Œæ”¯æŒæ•°æ®åˆ†æå’Œå¯è§†åŒ–ã€‚

#### æŠ€æœ¯æ–¹æ¡ˆ

```typescript
import * as XLSX from 'xlsx';

interface ExcelDocument {
  filePath: string;
  sheets: ExcelSheet[];
  metadata: {
    sheetCount: number;
    totalRows: number;
  };
}

interface ExcelSheet {
  name: string;
  data: any[][];          // åŸå§‹æ•°æ®
  headers: string[];      // è¡¨å¤´
  rows: Record<string, any>[]; // ç»“æ„åŒ–è¡Œ
  stats: SheetStatistics;
}

interface SheetStatistics {
  rowCount: number;
  columnCount: number;
  numericColumns: string[];
  textColumns: string[];
  summary: Record<string, any>; // ç»Ÿè®¡æ‘˜è¦
}

class ExcelDocumentProcessor {
  async read(filePath: string): Promise<ExcelDocument> {
    // 1. è¯»å–å·¥ä½œç°¿
    const workbook = XLSX.readFile(filePath);
    
    // 2. å¤„ç†æ¯ä¸ª Sheet
    const sheets = workbook.SheetNames.map(name => {
      const worksheet = workbook.Sheets[name];
      
      // è½¬æ¢ä¸º JSON
      const data: any[][] = XLSX.utils.sheet_to_json(worksheet, {
        header: 1
      });
      
      // æå–è¡¨å¤´
      const headers = data[0] as string[];
      
      // ç»“æ„åŒ–æ•°æ®
      const rows = data.slice(1).map(row => {
        const obj: Record<string, any> = {};
        headers.forEach((header, i) => {
          obj[header] = row[i];
        });
        return obj;
      });
      
      // è®¡ç®—ç»Ÿè®¡
      const stats = this.calculateStats(headers, rows);
      
      return {
        name,
        data,
        headers,
        rows,
        stats
      };
    });
    
    return {
      filePath,
      sheets,
      metadata: {
        sheetCount: sheets.length,
        totalRows: sheets.reduce((sum, s) => sum + s.rows.length, 0)
      }
    };
  }
  
  private calculateStats(headers: string[], rows: any[]): SheetStatistics {
    const stats: SheetStatistics = {
      rowCount: rows.length,
      columnCount: headers.length,
      numericColumns: [],
      textColumns: [],
      summary: {}
    };
    
    // è¯†åˆ«æ•°å€¼åˆ—
    headers.forEach(header => {
      const values = rows.map(row => row[header]).filter(v => v != null);
      const isNumeric = values.every(v => typeof v === 'number' || !isNaN(Number(v)));
      
      if (isNumeric && values.length > 0) {
        stats.numericColumns.push(header);
        
        // è®¡ç®—ç»Ÿè®¡é‡
        const numbers = values.map(Number);
        stats.summary[header] = {
          min: Math.min(...numbers),
          max: Math.max(...numbers),
          avg: numbers.reduce((a, b) => a + b, 0) / numbers.length,
          sum: numbers.reduce((a, b) => a + b, 0)
        };
      } else {
        stats.textColumns.push(header);
      }
    });
    
    return stats;
  }
  
  // æ•°æ®åˆ†æ
  async analyze(sheet: ExcelSheet, query: string): Promise<AnalysisResult> {
    // ä½¿ç”¨ LLM ç†è§£æŸ¥è¯¢æ„å›¾
    const intent = await this.parseQuery(query);
    
    switch (intent.type) {
      case 'sum':
        return this.sum(sheet, intent.column);
      case 'average':
        return this.average(sheet, intent.column);
      case 'groupBy':
        return this.groupBy(sheet, intent.groupColumn, intent.aggColumn);
      case 'filter':
        return this.filter(sheet, intent.condition);
      default:
        return this.customAnalysis(sheet, query);
    }
  }
  
  private sum(sheet: ExcelSheet, column: string) {
    const sum = sheet.rows.reduce((total, row) => {
      return total + (Number(row[column]) || 0);
    }, 0);
    
    return {
      type: 'sum',
      column,
      result: sum,
      formatted: `${column} æ€»è®¡: ${sum}`
    };
  }
  
  private groupBy(sheet: ExcelSheet, groupCol: string, aggCol: string) {
    const groups: Record<string, number> = {};
    
    sheet.rows.forEach(row => {
      const key = row[groupCol];
      const value = Number(row[aggCol]) || 0;
      groups[key] = (groups[key] || 0) + value;
    });
    
    return {
      type: 'groupBy',
      groups,
      formatted: Object.entries(groups)
        .map(([k, v]) => `${k}: ${v}`)
        .join('\n')
    };
  }
}
```

#### ä½¿ç”¨åœºæ™¯

```
ç”¨æˆ·: "åˆ†æè¿™ä¸ªé”€å”®æ•°æ®è¡¨"

å·¥å…·è°ƒç”¨: readExcelDocument({ filePath: "sales.xlsx" })

è¿”å›: {
  sheets: [{
    name: "é”€å”®æ•°æ®",
    headers: ["äº§å“", "é”€é‡", "é‡‘é¢"],
    rows: [
      { äº§å“: "A", é”€é‡: 100, é‡‘é¢: 50000 },
      { äº§å“: "B", é”€é‡: 150, é‡‘é¢: 75000 }
    ],
    stats: {
      summary: {
        é”€é‡: { min: 100, max: 150, avg: 125, sum: 250 },
        é‡‘é¢: { min: 50000, max: 75000, avg: 62500, sum: 125000 }
      }
    }
  }]
}

AI åˆ†æ:
ğŸ“Š é”€å”®æ•°æ®åˆ†æ

åŸºæœ¬ä¿¡æ¯:
- æ€»é”€é‡: 250 ä»¶
- æ€»é‡‘é¢: Â¥125,000
- å¹³å‡é”€é‡: 125 ä»¶/äº§å“

äº§å“è¡¨ç°:
- äº§å“ B é”€é‡æœ€é«˜ (150ä»¶)
- äº§å“ B è´¡çŒ®æœ€å¤§ (Â¥75,000)

å»ºè®®: å¯ä»¥åŠ å¤§äº§å“ B çš„æ¨å¹¿åŠ›åº¦
```

### 4. æ ¼å¼è½¬æ¢

#### åŠŸèƒ½è¯´æ˜

æ”¯æŒå¤šç§æ–‡æ¡£æ ¼å¼ä¹‹é—´çš„è½¬æ¢ã€‚

#### è½¬æ¢çŸ©é˜µ

| æºæ ¼å¼ | ç›®æ ‡æ ¼å¼ | æ”¯æŒåº¦ | è¯´æ˜ |
|--------|---------|--------|------|
| Word | Markdown | âœ… å®Œå…¨ | é«˜è´¨é‡è½¬æ¢ |
| Word | HTML | âœ… å®Œå…¨ | ä¿ç•™æ ¼å¼ |
| Word | PDF | ğŸ”„ è§„åˆ’ | éœ€è¦é¢å¤–åº“ |
| PDF | Markdown | âš ï¸ éƒ¨åˆ† | æ–‡æœ¬å‹ PDF |
| PDF | Text | âœ… å®Œå…¨ | OCR æ”¯æŒ |
| Excel | CSV | âœ… å®Œå…¨ | æ ‡å‡†è½¬æ¢ |
| Excel | JSON | âœ… å®Œå…¨ | ç»“æ„åŒ–æ•°æ® |
| Markdown | HTML | âœ… å®Œå…¨ | æ ‡å‡†è½¬æ¢ |
| Markdown | PDF | ğŸ”„ è§„åˆ’ | éœ€è¦æ¸²æŸ“å¼•æ“ |

#### å®ç°ç¤ºä¾‹

```typescript
class DocumentConverter {
  async convert(
    sourcePath: string,
    targetFormat: DocumentFormat
  ): Promise<ConversionResult> {
    // 1. æ£€æµ‹æºæ ¼å¼
    const sourceFormat = this.detectFormat(sourcePath);
    
    // 2. æŸ¥æ‰¾è½¬æ¢å™¨
    const converter = this.getConverter(sourceFormat, targetFormat);
    
    if (!converter) {
      throw new Error(`ä¸æ”¯æŒä» ${sourceFormat} è½¬æ¢åˆ° ${targetFormat}`);
    }
    
    // 3. æ‰§è¡Œè½¬æ¢
    const result = await converter.convert(sourcePath);
    
    // 4. ä¿å­˜ç»“æœ
    const outputPath = this.generateOutputPath(sourcePath, targetFormat);
    await fs.writeFile(outputPath, result.content);
    
    return {
      sourcePath,
      outputPath,
      sourceFormat,
      targetFormat,
      success: true
    };
  }
}
```

#### ä½¿ç”¨åœºæ™¯

```
ç”¨æˆ·: "æŠŠè¿™ä¸ª Word æ–‡æ¡£è½¬æˆ Markdown"

å·¥å…·è°ƒç”¨: convertDocument({
  filePath: "report.docx",
  targetFormat: "markdown"
})

è¿”å›: {
  outputPath: "report.md",
  success: true
}

AI å›å¤: "âœ… æ–‡æ¡£å·²æˆåŠŸè½¬æ¢ä¸º Markdown æ ¼å¼ï¼Œä¿å­˜åœ¨ report.md"
```

## ğŸ”§ å·¥å…·å®šä¹‰

### Function Calling å·¥å…·

```typescript
const documentTools: ToolDefinition[] = [
  {
    name: 'readWordDocument',
    description: 'è¯»å– Word æ–‡æ¡£å†…å®¹',
    parameters: {
      type: 'object',
      properties: {
        filePath: { type: 'string', description: 'æ–‡æ¡£è·¯å¾„' },
        extractTables: { type: 'boolean', description: 'æ˜¯å¦æå–è¡¨æ ¼', default: true }
      },
      required: ['filePath']
    }
  },
  {
    name: 'readPDFDocument',
    description: 'è¯»å– PDF æ–‡æ¡£å†…å®¹ï¼Œæ”¯æŒ OCR',
    parameters: {
      type: 'object',
      properties: {
        filePath: { type: 'string', description: 'PDF è·¯å¾„' },
        useOCR: { type: 'boolean', description: 'æ˜¯å¦ä½¿ç”¨ OCR', default: false }
      },
      required: ['filePath']
    }
  },
  {
    name: 'readExcelDocument',
    description: 'è¯»å– Excel è¡¨æ ¼æ•°æ®',
    parameters: {
      type: 'object',
      properties: {
        filePath: { type: 'string', description: 'Excel è·¯å¾„' },
        sheetName: { type: 'string', description: 'Sheet åç§° (å¯é€‰)' }
      },
      required: ['filePath']
    }
  },
  {
    name: 'analyzeExcelData',
    description: 'åˆ†æ Excel æ•°æ®',
    parameters: {
      type: 'object',
      properties: {
        filePath: { type: 'string', description: 'Excel è·¯å¾„' },
        query: { type: 'string', description: 'åˆ†ææŸ¥è¯¢ï¼Œå¦‚ "è®¡ç®—æ€»é”€å”®é¢"' }
      },
      required: ['filePath', 'query']
    }
  },
  {
    name: 'convertDocument',
    description: 'æ–‡æ¡£æ ¼å¼è½¬æ¢',
    parameters: {
      type: 'object',
      properties: {
        filePath: { type: 'string', description: 'æºæ–‡ä»¶è·¯å¾„' },
        targetFormat: { 
          enum: ['markdown', 'html', 'pdf', 'text', 'csv', 'json'],
          description: 'ç›®æ ‡æ ¼å¼'
        }
      },
      required: ['filePath', 'targetFormat']
    }
  }
];
```

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### ç›®æ ‡æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | è¯´æ˜ |
|------|--------|------|
| Word è§£æé€Ÿåº¦ | <3s (100é¡µ) | ä¸­ç­‰å¤§å°æ–‡æ¡£ |
| PDF è§£æé€Ÿåº¦ | <5s (100é¡µ) | æ–‡æœ¬å‹ PDF |
| OCR é€Ÿåº¦ | <10s/é¡µ | æ‰«æå‹ PDF |
| Excel è¯»å–é€Ÿåº¦ | <2s (10kè¡Œ) | ä¸­ç­‰æ•°æ®é‡ |
| æ ¼å¼è½¬æ¢é€Ÿåº¦ | <5s | Word â†’ Markdown |

## ğŸ—ºï¸ å¼€å‘è®¡åˆ’

### v0.3.0 (2026-03)

- [ ] Word æ–‡æ¡£è¯»å–
  - [ ] æ–‡æœ¬æå–
  - [ ] è¡¨æ ¼è§£æ
  - [ ] æ ¼å¼ä¿ç•™
- [ ] PDF æ–‡æ¡£è§£æ
  - [ ] æ–‡æœ¬å‹ PDF
  - [ ] OCR é›†æˆ
- [ ] Excel è¯»å–
  - [ ] åŸºç¡€è¯»å–
  - [ ] æ•°æ®ç»Ÿè®¡

### v0.4.0 (2026-04)

- [ ] æ ¼å¼è½¬æ¢
  - [ ] Word â†’ Markdown
  - [ ] Word â†’ HTML
  - [ ] Excel â†’ CSV/JSON
- [ ] Excel æ•°æ®åˆ†æ
  - [ ] ç»Ÿè®¡åˆ†æ
  - [ ] æŸ¥è¯¢è¯­è¨€

### v0.5.0 (2026-05)

- [ ] å›¾è¡¨ç”Ÿæˆ
- [ ] æ‰¹é‡å¤„ç†
- [ ] é«˜çº§åˆ†æ

## ğŸ“š å‚è€ƒèµ„æ–™

- [docx npm package](https://www.npmjs.com/package/docx)
- [mammoth.js](https://github.com/mwilliamson/mammoth.js)
- [pdf-parse](https://www.npmjs.com/package/pdf-parse)
- [SheetJS (xlsx)](https://sheetjs.com/)
- [Tesseract.js (OCR)](https://tesseract.projectnaptha.com/)

---

**[[äº§å“éœ€æ±‚æ–‡æ¡£|è¿”å› PRD ä¸»é¡µ]]**
