# 落地步骤

> 生成日期: [[2025-06-18]]
> 来源: Claude 对项目开发组回复的技术落地建议

---

::: callout
**落地目标**
将 Claude 的技术建议转化为可执行的开发任务，按优先级推进，确保每个改进点都有明确的实现路径和验收标准。
:::

## 📋 落地优先级

| 优先级 | 模块 | 核心目标 | 预计工作量 |
|--------|------|----------|------------|
| P0 | Daemon 稳定性 | 结构化日志 + 崩溃恢复策略 | 中 | 
| P0 | executeCommand 安全 | 权限分级控制 | 小 | 
| P1 | 用户体验 | 模型切换提示 + 流式响应优化 | 中 | 
| P2 | 扩展准备 | DIANA/ANDERS 接口预留 | 大 |

---

## 🎯 P0-1: Daemon 稳定性

### 1.1 结构化日志

**需求**:
- 在 `daemon/logger.ts` 中实现 JSON 行日志输出
- 日志必须包含 `sessionId` 和 `traceId` 字段
- 与现有可读日志并存，通过配置开关控制

**实现要点**:
```typescript
interface StructuredLog {
  timestamp: string;
  level: 'info' | 'warn' | 'error';
  sessionId: string;
  traceId: string;
  service: 'daemon' | 'cli';
  message: string;
  [key: string]: any;
}
```

**验收标准**:
- [ ] 日志可通过 `grep sessionId=xxx` 快速过滤
- [ ] 日志可通过 ELK/Graylog 等工具解析
- [ ] 默认关闭，生产环境显式开启

### 1.2 崩溃恢复策略

**需求**:
- 明确 CLI 发现 daemon 不可用时的行为
- 实现退避重试机制：1s → 3s → 10s
- CLI 维护 `lastSuccessTimestamp`，超过阈值才触发 spawn

**实现要点**:
```typescript
interface DaemonRecovery {
  retryBackoff: [1000, 3000, 10000];  // 毫秒
  minSuccessInterval: number;  // 5分钟
  enableAutoSpawn: boolean;
}
```

**验收标准**:
- [ ] 配置文件中明确标注恢复策略
- [ ] 避免因配置错误导致循环重启
- [ ] 用户可配置是否允许自动 spawn

---

## 🎯 P0-2: executeCommand 安全控制

### 2.1 权限分级设计

**需求**:
- 配置项分为三个级别：`readonly`、`standard`、`unrestricted`
- `readonly`: 仅允许读操作（ls/cat/grep）
- `standard`: 默认，黑名单过滤 + 用户确认
- `unrestricted`: 完全放开，需用户主动开启

**实现要点**:
```yaml
# config.yaml
dangerous_cmd:
  level: standard  # readonly | standard | unrestricted
  whitelist:
    - ls
    - cat
    - grep
  blacklist:
    - rm
    - rmdir
    - dd
```

**验收标准**:
- [ ] 配置文档清晰说明每个级别的含义
- [ ] `standard` 级别必须通过 `askUser` 确认
- [ ] `unrestricted` 级别在 UI 上显著提示风险

### 2.2 风险提示

**需求**:
- 在文档中明确当前唯一防线是「危险命令列表 + 确认」
- 生产环境建议勿关闭 `dangerous_cmd`

**验收标准**:
- [ ] README.md 中包含安全最佳实践章节
- [ ] 配置文件注释中标注默认开启原因

---

## 🎯 P1: 用户体验打磨

### 3.1 模型切换提示

**需求**:
- 在 TUI 状态栏或首条内容前插入轻量提示
- 提示包含：切换原因 + 新模型名称
- 示例：「已切换至备用模型：gpt-4o（主模型返回 429）」

**实现要点**:
```typescript
interface ModelSwitchNotification {
  reason: 'rate_limit' | 'timeout' | 'error';
  originalModel: string;
  fallbackModel: string;
  timestamp: string;
}
```

**验收标准**:
- [ ] 用户明确知道发生了模型切换
- [ ] 提示持续显示约 3 秒后自动消失
- [ ] 控制台保留警告日志，便于排查

### 3.2 会话一致性提示

**需求**:
- daemon 返回的 session 响应带 `version` 或 `updatedAt` 字段
- CLI 重连时比较版本，日志记录「本地缓存已废弃」

**验收标准**:
- [ ] 日志中可追溯本地缓存何时被废弃
- [ ] 用户无感知，但问题可排查

---

## 🎯 P2: 扩展准备

### 4.1 DIANA/ANDERS 接口预留

**需求**:
- 新 Agent 采用「新客户端 + 同一或扩展协议」方式接入
- 避免大规模重构 alice/veronica 核心

**实现要点**:
- [ ] 在现有 daemon/CLI 分离和事件协议基础上扩展
- [ ] REFACTOR_PLAN 中单独设计接口形态

**验收标准**:
- [ ] 接口文档与实现同步更新
- [ ] 向后兼容现有 alice/veronica 客户端

---

## 📅 迭代排期建议

### 第一阶段（1-2周）
- [ ] P0-1: Daemon 结构化日志
- [ ] P0-2: executeCommand 权限分级文档化

### 第二阶段（2-3周）
- [ ] P0-1: Daemon 崩溃恢复策略
- [ ] P0-2: executeCommand 权限分级实现
- [ ] P1: 模型切换提示实现

### 第三阶段（3-4周）
- [ ] P1: 流式响应优化
- [ ] P2: DIANA/ANDERS 接口设计

---

## ✅ 验收清单

每个任务完成后，需确认以下项目：

- [ ] 代码变更已提交并关联 issue
- [ ] 相关文档已更新
- [ ] 测试用例通过（单元测试 + 集成测试）
- [ ] 代码审查通过
- [ ] 性能测试无明显回归

---

## 📚 相关文档

- [[Claude的建议1.md]] - 原始建议与团队回复
- [[REFACTOR_PLAN]] - 重构计划
- [[config.yaml]] - 配置项说明

---

%%
落地步骤持续更新中，每次迭代后更新任务状态和完成日期
%%
## 几个值得思考的方向

**1. Daemon 的稳定性与可观测性**

常驻进程是整个系统的核心，但也是最容易出问题的地方。目前文档里提到了心跳，但需要考虑：Daemon 崩溃后 CLI 的重启策略是什么？有没有结构化日志（比如 JSON 格式）方便排查？`processManager` 目前的职责边界是否清晰？

**2. 工具执行的安全边界**

`executeCommand` 这个内置工具是个高风险点。用户或者 LLM 生成的指令如果没有沙箱或白名单，在生产使用中可能存在安全隐患。建议考虑权限分级，或者至少在执行前有一个明确的用户确认步骤（`askUser` 已经有了，但需要确认是否强制触发）。

**3. 会话持久化的一致性**

文档里提到"会话由 Daemon 持有，CLI 侧 sessionManager 做本地持久化"，这个双写架构在异常场景下（比如 Daemon 中途崩溃）容易产生数据不一致。需要明确谁是 source of truth，以及恢复策略。

**4. MCP 工具的命名空间**

`mcp__{server}__{toolName}` 这个命名方案在工具数量多的时候，会对 LLM 的 function calling 选择产生压力（上下文里工具列表太长）。可以考虑动态工具加载，或者按任务类型做工具分组，避免一次性把所有 MCP 工具都塞给模型。

**5. 错误降级的用户体验**

`suggest_model` 自动切换备用模型是个好设计，但用户是否知道发生了切换？静默降级有时会让用户困惑（"为什么回复风格变了"）。建议在 TUI 里有一个轻量的提示。

---

## 下一步的建议优先级

如果要继续迭代，我建议按这个顺序考虑：

1. **稳定性**：Daemon 崩溃恢复 + 结构化日志
2. **安全性**：`executeCommand` 权限控制
3. **体验打磨**：流式响应的中断/重试、切换模型提示
4. **扩展准备**：为 DIANA / ANDERS 做好接口预留，避免后期大规模重构

---

## 项目开发组回复（编码侧）

> 以下为实际参与编码的同事基于当前实现与路线图所做的回应，供与 Claude 的建议对照、迭代用。

### 1. Daemon 的稳定性与可观测性

**现状**：目前 Daemon 侧有 `daemon/logger.ts`，输出为普通文本；心跳在 `daemon/config` 中可配，CLI 通过 `DaemonClient` 与 daemon 通信，若 daemon 不可达会表现为连接失败，暂无自动拉起 daemon 的逻辑。

**回复**：认同这是核心。计划内会做两件事：（1）**结构化日志**：daemon 日志改为可选的 JSON 行输出（便于 grep/ELK），与现有可读日志并存；（2）**崩溃与重启策略**：明确「CLI 发现 daemon 不可用时的行为」——例如提示用户执行 `veronica start`，或可选地在本地做一次短超时后的自动 spawn（需权衡与进程归属、权限）。`processManager` 的职责会在文档里写清：仅负责 daemon 进程的启动/停止/状态查询，不承担业务会话逻辑。

### 2. 工具执行的安全边界（executeCommand）

**现状**：`executeCommand` 会走危险命令检测（`isDangerousCommand`），若命中则依赖 TUI 侧的「危险命令确认」弹窗（`DangerousCommandConfirm`）；配置项 `dangerous_cmd` 可关闭确认（默认开启）。暂无沙箱或白名单，确认后即执行。

**回复**：同意这是高风险点。短期不会引入沙箱（实现与平台差异大），但会做：（1）在文档和配置中明确「危险命令列表 + 确认」是当前唯一防线，建议生产环境勿关闭 `dangerous_cmd`；（2）可选增强：对 `executeCommand` 做**权限分级**（如只读命令集 vs 可写/可执行命令集），在配置里允许用户限定仅允许执行某类命令（白名单/正则），与现有危险命令黑名单并存。`askUser` 已用于需用户输入的场景，危险命令路径不会改为强制走 `askUser`，而是继续用专用确认组件并保留配置开关。

### 3. 会话持久化的一致性

**现状**：Source of truth 是 **Daemon**：会话与消息由 daemon 的 session 管理，CLI 在 `done` 事件时用服务端下发的 `event.messages` 更新本地 state；本地 `sessionManager` 用于持久化与统计（如退出汇报），初始化时通过 `applySession` 与 daemon 同步。

**回复**：双写仅发生在「daemon 正常返回 done」时 CLI 更新本地；若 daemon 中途崩溃，CLI 侧不会自行改写会话内容，因此不会出现「CLI 覆盖 daemon」的一致性问题。但确实存在「daemon 崩溃后本地缓存的会话与 daemon 重启后状态不一致」的情况。后续会：（1）在文档中明确「Daemon 为会话的 source of truth」；（2）在 daemon 重启或 CLI 检测到 daemon 重连时，优先以 daemon 返回的会话为准，必要时丢弃或仅作展示用的本地缓存，避免用本地旧数据覆盖服务端。

### 4. MCP 工具的命名空间与上下文压力

**现状**：MCP 工具统一命名为 `mcp__{server}__{toolName}`，全部注册进 `ToolRegistry`，当前是一次性把全部工具以 OpenAI function 形式发给模型。

**回复**：认同工具过多会拉长上下文、影响选择质量。后续可以考虑：（1）**按需/按任务加载**：根据当前会话或用户设置，只启用部分 MCP server 或工具子集；（2）**分组/描述优化**：在工具描述或分组上做结构化，便于模型区分；（3）若 MCP 协议侧支持「工具发现的分页或按能力查询」，再对接。实现会优先做配置级「启用/禁用某 MCP server」，再视需要做更细粒度的动态加载。

### 5. 错误降级（suggest_model）的用户体验

**现状**：主模型失败时若配置了 `suggest_model`，会静默切换到备用模型，并在控制台打出一行警告（含“已自动切换到备用模型”及 `alice --test-model` 提示），TUI 内没有单独的状态条或 toast。

**回复**：会改进为在 TUI 内做**轻量提示**：例如在状态栏或单行提示中短暂显示「已切换至备用模型：xxx」，或在首条流式内容前插入一行固定提示，避免用户误以为「风格突变」是模型抽风。控制台警告保留，便于脚本/日志排查。

---

### 关于建议优先级的回应

- **稳定性（Daemon 崩溃恢复 + 结构化日志）**：纳入近期迭代，先做结构化日志与文档化重启/重连策略，再视情况做 CLI 侧轻量自动拉起。
- **安全性（executeCommand 权限控制）**：先文档化当前风险与配置建议，再实现可选白名单/分级，不承诺沙箱。
- **体验打磨（流式中断/重试、模型切换提示）**：模型切换提示会做；流式中断/重试与现有错误处理一起排期。
- **扩展准备（DIANA/ANDERS 接口预留）**：在现有 daemon/CLI 分离和事件协议基础上，新 Agent 会以「新客户端 + 同一或扩展协议」方式接入，避免大改现有 alice/veronica 核心；具体接口形态会在 REFACTOR_PLAN 或单独设计稿里补充。

感谢 Claude 的提问与建议，上述回复会随实现进展在文档和代码中同步更新。


# Claude的结论具体落地细节:

感谢团队详细的回复，方向和思路都很清晰。我来针对每条回复做进一步的技术建议，帮助你们把落地细节想得更具体。
逐条深入
1. Daemon 稳定性
结构化日志方向很对。补充一个细节：JSON 日志里建议强制包含 sessionId 和 traceId 字段，这样排查"某次对话为什么失败"时可以直接过滤，不用肉眼扫全部日志。
关于自动拉起的权衡，你们提到"短超时后自动 spawn"——建议加一个退避重试（比如 1s → 3s → 10s），避免 daemon 因为某个配置错误反复崩溃重启形成循环。同时 CLI 侧可以维护一个"上次成功连接时间戳"，超过阈值才触发 spawn，而不是每次连接失败都尝试。
2. executeCommand 安全
你们提到白名单/正则的方向是对的。具体实现建议参考最小权限原则：配置项可以设计为三个级别——readonly（只允许读操作如 ls/cat/grep）、standard（默认，黑名单过滤）、unrestricted（完全放开，明确需要用户主动开启）。这样比单纯正则白名单更易于用户理解，也更容易写文档。
3. 会话一致性
你们对边界的分析是准确的，Daemon 重启后"本地缓存旧于服务端"这个场景处理好了就基本稳了。建议在 daemon 返回的 session 响应里带一个版本号或 updatedAt，CLI 在重连时做一次比较，日志里记录"本地缓存已废弃，以 daemon 为准"，这样排查问题时也有迹可循。
4. MCP 工具上下文压力
配置级"启用/禁用某 server"是很好的第一步。但有一个更轻量的补充方案值得考虑：在构造发给 LLM 的工具列表时，可以根据对话上下文做关键词匹配，动态决定把哪些工具注入。比如用户的 message 里出现了文件路径，才把文件相关工具加入。这个方案不需要改 MCP 协议，实现成本低，效果也会比较明显。
5. 模型切换提示
你们的方案（状态栏或首条内容前插入提示）完全够用。补充一个小建议：提示里最好同时告诉用户为什么切换（比如"主模型 xxx 返回 429，已自动切换至 yyy"），而不只是"已切换"。这样用户能判断是自己的 API Key 余额不足还是模型服务本身有问题，减少困惑。